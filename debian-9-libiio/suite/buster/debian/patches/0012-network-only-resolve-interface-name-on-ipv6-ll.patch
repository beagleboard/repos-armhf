From 0fbb31f669b22f7b66d7bb21eece3bc0cc804267 Mon Sep 17 00:00:00 2001
From: Jorik Jonker <jorik@kippendief.biz>
Date: Fri, 26 Jul 2019 09:32:32 +0200
Subject: [PATCH 12/12] network: only resolve interface name on ipv6 ll

It turns out that resolving interface name from
sockaddr_in6->sin6_scope_id only works on link-local addresses. This
resulted in errors when connecting to iiod over global ipv6.

The man page on sin6_scope_id states that: "Linux supports it only for
link-local addresses, in that case sin6_scope_id contains the interface
index."

The macro IN6_IS_ADDR_LINKLOCAL seems appropriate to test this.

I have not been able to test this on WIN32, but I have found multiple
pieces of win32 code using this macro, which all seem to pull it from
<ws2tcpip.h> which is already included in network.c so I'm confident it
will work.

fixes analogdevicesinc/libiio#296

Signed-off-by: Jorik Jonker <jorik@kippendief.biz>
---
 network.c | 18 ++++++++++--------
 1 file changed, 10 insertions(+), 8 deletions(-)

diff --git a/network.c b/network.c
index ab6fe38..b94f841 100644
--- a/network.c
+++ b/network.c
@@ -1537,15 +1537,17 @@ struct iio_context * network_create_context(const char *host)
 		inet_ntop(AF_INET6, &in->sin6_addr,
 				description, INET6_ADDRSTRLEN);
 
-		ptr = if_indextoname(in->sin6_scope_id, description +
-				strlen(description) + 1);
-		if (!ptr) {
-			ret = -errno;
-			ERROR("Unable to lookup interface of IPv6 address\n");
-			goto err_free_description;
-		}
+		if (IN6_IS_ADDR_LINKLOCAL(&in->sin6_addr)) {
+			ptr = if_indextoname(in->sin6_scope_id, description +
+					strlen(description) + 1);
+			if (!ptr) {
+				ret = -errno;
+				ERROR("Unable to lookup interface of IPv6 address\n");
+				goto err_free_description;
+			}
 
-		*(ptr - 1) = '%';
+			*(ptr - 1) = '%';
+		}
 	}
 #endif
 	if (res->ai_family == AF_INET) {
-- 
2.20.1

